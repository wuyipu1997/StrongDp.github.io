<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DDD实战课笔记（一）]]></title>
    <url>%2F2020%2F03%2F25%2FDDD%E5%AE%9E%E6%88%98%E8%AF%BE%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DDD实战课01 | 微服务设计为什么要选择DDD？微服务边界划定问题 我们知道，微服务设计过程中往往会面临边界如何划定的问题，我经常看到项目团队为微服务到底应该拆多小而争得面红耳赤。不同的人会根据自己对微服务的理解而拆分出不同的微服务，于是大家各执一词，谁也说服不了谁，都觉得自己很有道理。 那在实际落地过程中，我也确实见过不少项目在面临这种微服务设计困惑时，是靠拍脑袋硬完成的，上线后运维的压力就可想而知了。那是否有合适的理论或设计方法来指导微服务设计呢？就是 DDD。 软件架构模式的演进 第一阶段是单机架构 采用面向过程的设计方法，系统包括客户端 UI 层和数据库两层，采用 C/S 架构模式，整个系统围绕数据库驱动设计和开发，并且总是从设计数据库和字段开始。 第二阶段是集中式架构 采用面向对象的设计方法，系统包括业务接入层、业务逻辑层和数据库层，采用经典的三层架构，也有部分应用采用传统的 SOA 架构。这种架构容易使系统变得臃肿，可扩展性和弹性伸缩性差。 第三阶段是分布式微服务架构 随着微服务架构理念的提出，集中式架构正向分布式微服务架构演进。微服务架构可以很好地实现应用之间的解耦，解决单体应用扩展性和弹性伸缩能力不足的问题。 痛点 在单机和集中式架构时代，系统分析、设计和开发往往是独立、分阶段割裂进行的。 比如，在系统建设过程中，我们经常会看到这样的情形：A 负责提出需求，B 负责需求分析，C 负责系统设计，D 负责代码实现，这样的流程很长，经手的人也很多，很容易导致信息丢失。最后，就很容易导致需求、设计与代码实现的不一致，往往到了软件上线后，我们才发现很多功能并不是自己想要的，或者做出来的功能跟自己提出的需求偏差太大。 而且在单机和集中式架构这两种模式下，软件无法快速响应需求和业务的迅速变化，最终错失发展良机。 微服务设计和拆分的困境 作者认为微服务拆分困境产生的根本原因就是不知道业务或者微服务的边界到底在什么地方。换句话说，确定了业务边界和应用边界，这个困境也就迎刃而解了。 领域驱动设计与微服务的前世今生 2004 年埃里克·埃文斯（Eric Evans）发表了《领域驱动设计》（Domain-Driven Design –Tackling Complexity in the Heart of Software）这本书，从此领域驱动设计（Domain Driven Design，简称 DDD）诞生。 DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。 但 DDD 提出后在软件开发领域一直都是“雷声大，雨点小”！直到 Martin Fowler 提出微服务架构，DDD 才真正迎来了自己的时代。 为什么 DDD 适合微服务？ DDD是什么 DDD 是一种处理高度复杂领域的设计思想，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。DDD 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。 DDD 战略设计 战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的限界上下文，限界上下文可以作为微服务设计的参考边界。 战术设计 战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。 如何进行战略设计 DDD 战略设计会建立领域模型，领域模型可以用于指导微服务的设计和拆分。 事件风暴是建立领域模型的主要方法，它是一个从发散到收敛的过程。它通常采用用例分析、场景分析和用户旅程分析，尽可能全面不遗漏地分解业务领域，并梳理领域对象之间的关系，这是一个发散的过程。事件风暴过程会产生很多的实体、命令、事件等领域对象，我们将这些领域对象从不同的维度进行聚类，形成如聚合、限界上下文等边界，建立领域模型，这就是一个收敛的过程。 我们可以用三步来划定领域模型和微服务的边界。 图示 步骤 第一步：在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出领域实体等领域对象。 第二步：根据领域实体之间的业务关联性，将业务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。在这个图里，聚合之间的边界是第一层边界，它们在同一个微服务实例中运行，这个边界是逻辑边界，所以用虚线表示。 第三步：根据业务及语义边界等因素，将一个或者多个聚合划定在一个限界上下文内，形成领域模型。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界，边界之间用实线来表示。 结果 在战略设计中我们建立了领域模型，划定了业务领域的边界，建立了通用语言和限界上下文，确定了领域模型中各个领域对象的关系。到这儿，业务端领域模型的设计工作基本就完成了，这个过程同时也基本确定了应用端的微服务边界。 在从业务模型向微服务落地的过程中，也就是从战略设计向战术设计的实施过程中，我们会将领域模型中的领域对象与代码模型中的代码对象建立映射关系，将业务架构和系统架构进行绑定。当我们去响应业务变化调整业务架构和领域模型时，系统架构也会同时发生调整，并同步建立新的映射关系。 DDD 与微服务的关系 DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。两者都强调从业务出发，其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。 DDD 主要关注 从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。 微服务主要关注 运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。 总结 DDD 可以给你带来以下收获 DDD 是一套完整而系统的设计方法，它能带给你从战略设计到战术设计的标准设计过程，使得你的设计思路能够更加清晰，设计过程更加规范。 DDD 善于处理与领域相关的拥有高复杂度业务的产品开发，通过它可以建立一个核心而稳定的领域模型，有利于领域知识的传递与传承。 DDD 强调团队与领域专家的合作，能够帮助你的团队建立一个沟通良好的氛围，构建一致的架构体系。 DDD 的设计思想、原则与模式有助于提高你的架构设计能力。 无论是在新项目中设计微服务，还是将系统从单体架构演进到微服务，都可以遵循 DDD 的架构原则。 DDD 不仅适用于微服务，也适用于传统的单体应用。 02 | 领域、子域、核心域、通用域和支撑域如何理解领域和子域？ 领域 领域就是用来确定范围的，范围即边界，这也是 DDD 在设计中不断强调边界的原因。 在研究和解决业务问题时，DDD 会按照一定的规则将业务领域进行细分，当领域细分到一定的程度后，DDD 会将问题范围限定在特定的边界内，在这个边界内建立领域模型，进而用代码实现该领域模型，解决相应的业务问题。简言之，DDD 的领域就是这个边界内要解决的业务问题域。 子域 既然领域是用来限定业务边界和范围的，那么就会有大小之分，领域越大，业务范围就越大，反之则相反。 领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。 研究过程 第一步：确定研究对象，即研究领域，这里是一棵桃树。 第二步：对研究对象进行细分，将桃树细分为器官，器官又分为营养器官和生殖器官两种。。其中营养器官包括根、茎和叶，生殖器官包括花、果实和种子。桃树对应 DDD 的领域。根、茎、叶、花、果实和种子等器官则是细分后的问题子域。 第三步：对器官进行细分，将器官细分为组织。比如，叶子器官可细分为保护组织、营养组织和输导组织等。这个过程就是 DDD 将子域进一步细分为多个子域的过程。 第四步：对组织进行细分，将组织细分为细胞，细胞成为我们研究的最小单元。细胞之间的细胞壁确定了单元的边界，也确定了研究的最小边界。 我们知道细胞核、线粒体、细胞膜等物质共同构成细胞，这些物质一起协作让细胞具有这类细胞特定的生物功能。在这里你可以把细胞理解为 DDD 的聚合，细胞内的这些物质就可以理解为聚合里面的聚合根、实体以及值对象等，在聚合内这些实体一起协作完成特定的业务功能。这个过程类似 DDD 设计时，确定微服务内功能要素和边界的过程。 领域建模和微服务建设的过程和方法基本类似，其核心思想就是将问题域逐步分解，降低业务理解和系统实现的复杂度。核心域、通用域和支撑域 核心域 决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。 通用域 没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域。 举例来说的话，通用域则是你需要用到的通用系统，比如认证、权限等等，这类应用很容易买到，没有企业特点限制，不需要做太多的定制化。 支撑域 这种功能子域是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域。 支撑域则具有企业特性，但不具有通用性，例如数据代码类的数据字典等系统。 例子 拿上图的桃树来说吧。我们将桃树细分为了根、茎、叶、花、果实和种子等六个子域，那桃树是否有核心域？有的话，到底哪个是核心域呢 不同的人对桃树的理解是不同的。如果这棵桃树生长在公园里，在园丁的眼里，他喜欢的是“人面桃花相映红”的阳春三月，这时花就是桃树的核心域。但如果这棵桃树生长在果园里，对果农来说，他则是希望在丰收的季节收获硕果累累的桃子，这时果实就是桃树的核心域。 在不同的场景下，不同的人对桃树核心域的理解是不同的，因此对桃树的处理方式也会不一样。园丁更关注桃树花期的营养，而果农则更关注桃树落果期的营养，有时为了保证果实的营养供给，还会裁剪掉疯长的茎和叶（通用域或支撑域）。 现实例子 同样，公司在 IT 系统建设过程中，由于预算和资源有限，对不同类型的子域应有不同的关注度和资源投入策略，记住好钢要用在刀刃上。 很多公司的业务，表面看上去相似，但商业模式和战略方向是存在很大差异的，因此公司的关注点会不一样，在划分核心域、通用域和支撑域时，其结果也会出现非常大的差异。 比如同样都是电商平台的淘宝、天猫、京东和苏宁易购，他们的商业模式是不同的。淘宝是 C2C 网站，个人卖家对个人买家，而天猫、京东和苏宁易购则是 B2C 网站，是公司卖家对个人买家。即便是苏宁易购与京东都是 B2C 的模式，他们的商业模式也是不一样的，苏宁易购是典型的传统线下卖场转型成为电商，京东则是直营加部分平台模式。 商业模式的不同会导致核心域划分结果的不同。有的公司核心域可能在客户服务，有的可能在产品质量，有的可能在物流。在公司领域细分、建立领域模型和系统建设时，我们就要结合公司战略重点和商业模式，找到核心域了，且重点关注核心域。 03 | 限界上下文：定义领域边界的利器通用语言和限界上下文 两者相辅相成，通用语言定义上下文含义，限界上下文则定义领域边界，以确保每个上下文含义在它特定的边界内都具有唯一的含义，领域模型则存在于这个边界之内。 什么是通用语言？ 概念 在事件风暴过程中，通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是通用语言。也就是说，通用语言是团队统一的语言，不管你在团队中承担什么角色，在同一个领域的软件生命周期里都使用统一的语言进行交流。 通用语言包含术语和用例场景，并且能够直接反映在代码中。通用语言中的名词可以给领域对象命名，如商品、订单等，对应实体对象；而动词则表示一个动作或事件，如商品已下单、订单已付款等，对应领域事件或者命令。 价值 它可以解决交流障碍这个问题，使领域专家和开发人员能够协同合作，从而确保业务需求的正确表达。 DDD完整过程 ① 在事件风暴的过程中，领域专家会和设计、开发人员一起建立领域模型，在领域建模的过程中会形成通用的业务术语和用户故事。事件风暴也是一个项目团队统一语言的过程。 ② 通过用户故事分析会形成一个个的领域对象，这些领域对象对应领域模型的业务对象，每一个业务对象和领域对象都有通用的名词术语，并且一一映射。 ③ 微服务代码模型来源于领域模型，每个代码模型的代码对象跟领域对象一一对应。 设计过程中我们可以用一些表格，来记录事件风暴和微服务设计过程中产生的领域对象及其属性。 强调 DDD 分析和设计过程中的每一个环节都需要保证限界上下文内术语的统一，在代码模型设计的时侯就要建立领域对象和代码对象的一一映射，从而保证业务模型和代码模型的一致，实现业务语言与代码语言的统一。 什么是限界上下文？ 我们可以将限界上下文拆解为两个词：限界和上下文。限界就是领域的边界，而上下文则是语义环境。通过领域的限界上下文，我们就可以在统一的领域边界内用统一的语言进行交流。 定义 用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。 这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。 进一步理解限界上下文 语言离不开它的语义环境。 而业务的通用语言就有它的业务边界，我们不大可能用一个简单的术语没有歧义地去描述一个复杂的业务领域。限界上下文就是用来细分领域，从而定义通用语言所在的边界。 限界上下文和微服务的关系 保险模型 首先，领域可以拆分为多个子领域。一个领域相当于一个问题域，领域拆分为子域的过程就是大问题拆分为小问题的过程。 子域还可根据需要进一步拆分为子子域，比如，支付子域可继续拆分为收款和付款子子域。拆到一定程度后，有些子子域的领域边界就可能变成限界上下文的边界了。 子域可能会包含多个限界上下文，如理赔子域就包括报案、查勘和定损等多个限界上下文（限界上下文与理赔的子子域领域边界重合）。也有可能子域本身的边界就是限界上下文边界，如投保子域。 每个领域模型都有它对应的限界上下文，团队在限界上下文内用通用语言交流。领域内所有限界上下文的领域模型构成整个领域的领域模型。 理论上限界上下文就是微服务的边界。我们将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案。 04 | 实体和值对象：从领域模型的基础单元看系统设计实体 在 DDD 中有这样一类对象，它们拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。 实体的业务形态 领域模型中的实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合。 实体的代码形态 在代码模型中，实体的表现形式是实体类，这个类包含了实体的属性和方法，通过这些方法实现实体自身的业务逻辑。在 DDD 里，这些实体类通常采用充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现。 实体的运行形态 实体以 DO（领域对象）的形式存在，每个实体对象都有唯一的 ID。 实体的数据库形态 与传统数据模型设计优先不同，DDD 是先构建领域模型，针对实际业务场景构建实体对象和行为，再将实体对象映射到数据持久化对象。 在领域模型映射到数据模型时，一个实体可能对应 0 个、1 个或者多个数据库持久化对象。大多数情况下实体与持久化对象是一对一。在某些场景中，有些实体只是暂驻静态内存的一个运行态实体，它不需要持久化。比如，基于多个价格配置数据计算后生成的折扣实体。 而在有些复杂场景下，实体与持久化对象则可能是一对多或者多对一的关系。比如，用户 user 与角色 role 两个持久化对象可生成权限实体，一个实体对应两个持久化对象，这是一对多的场景。再比如，有些场景为了避免数据库的联表查询，提升系统性能，会将客户信息 customer 和账户信息 account 两类数据保存到同一张数据库表中，客户和账户两个实体可根据需要从一个持久化对象中生成，这就是多对一的场景。 值对象 定义 通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。 值对象的业务形态 值对象是 DDD 领域模型中的一个基础对象，它跟实体一样都来源于事件风暴所构建的领域模型，都包含了若干个属性，它与实体一起构成聚合。 值对象的代码形态 例如人这个实体中的 地址属性 值对象的运行形态 值对象嵌入到实体的话，有这样两种不同的数据格式，也可以说是两种方式，分别是属性嵌入的方式和序列化大对象的方式。 属性嵌入 序列化大对象 值对象的数据库形态 DDD 引入值对象是希望实现从“数据建模为中心”向“领域建模为中心”转变，减少数据库表的数量和表与表之间复杂的依赖关系，尽可能地简化数据库设计，提升数据库性能。 如何理解用值对象来简化数据库设计呢？ 传统的数据建模大多是根据数据库范式设计的，每一个数据库表对应一个实体，每一个实体的属性值用单独的一列来存储，一个实体主表会对应 N 个实体从表。而值对象在数据库持久化方面简化了设计，它的数据库设计大多采用非数据库范式，值对象的属性值和实体对象的属性值保存在同一个数据库实体表中。 即不管范式 总结 在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计。 值对象的优势和局限 优势 值对象是一把双刃剑，它的优势是可以简化数据库设计，提升数据库性能。 劣势 值对象采用序列化大对象的方法简化了数据库设计，减少了实体表的数量，可以简单、清晰地表达业务概念。这种设计方式虽然降低了数据库设计的复杂度，但却无法满足基于值对象的快速查询，会导致搜索值对象属性值变得异常困难。 值对象采用属性嵌入的方法提升了数据库的性能，但如果实体引用的值对象过多，则会导致实体堆积一堆缺乏概念完整性的属性，这样值对象就会失去业务涵义，操作起来也不方便。 实体和值对象的关系 DDD 提倡从领域模型设计出发，而不是先设计数据模型。 传统的数据模型设计通常是一个表对应一个实体，一个主表关联多个从表，当实体表太多的时候就很容易陷入无穷无尽的复杂的数据库设计，领域模型就很容易被数据模型绑架。可以说，值对象的诞生，在一定程度上，和实体是互补的。 05 | 聚合和聚合根：怎样设计聚合？聚合 领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保在这些领域对象在实现共同的业务逻辑时，能保证数据的一致性 聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化 聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。 聚合根 聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。 如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也成为根实体，它不仅是实体，还是聚合的管理者。 首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。 其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑 最后在聚合之间，它还是聚合对外的接口人，以聚合根ID关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根ID相关联引用，如果需要访问其他聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体 怎么设计聚合 聚合的一些设计原则 1、在一致性边界内建模真正的不变条件。 2、设计小聚合 3、通过唯一标识引用其它聚合 4、在边界之外使用最终一致性 聚合内数据强一致性，而聚合之间数据最终一致性。在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的方式异步修改相关的聚合，实现聚合之间的解耦。 5、通过应用层实现跨聚合的服务调用 06 | 领域事件：解耦微服务的关键领域事件 微服务内的领域事件 当领域事件发生在微服务内的聚合之间，领域事件发生后完成事件实体构建和事件数据持久化，发布方聚合将事件发布到事件总线，订阅方接收事件数据完成后续业务操作。 微服务内大部分事件的集成，都发生在同一个进程内，进程自身可以很好地控制事务，因此不一定需要引入消息中间件。 微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，这种方式通常应用于实时性和数据一致性要求高的场景。这个过程会用到分布式事务，以保证发布方和订阅方的数据同时更新成功。 微服务之间的领域事件 跨微服务的领域事件会在不同的限界上下文或领域模型之间实现业务协作，其主要目的是实现微服务解耦，减轻微服务之间实时服务访问的压力。 领域事件发生在微服务之间的场景比较多，事件处理的机制也更加复杂。跨微服务的事件可以推动业务流程或者数据在不同的子域或微服务间直接流转。 跨微服务的事件机制要总体考虑事件构建、发布和订阅、事件数据持久化、消息中间件，甚至事件数据持久化时还可能需要考虑引入分布式事务机制等。 微服务之间的访问也可以采用应用服务直接调用的方式，实现数据和服务的实时访问，弊端就是跨微服务的数据同时变更需要引入分布式事务，以确保数据的一致性。分布式事务机制会影响系统性能，增加微服务之间的耦合，所以我们还是要尽量避免使用分布式事务。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[我是如何学习Spring IOC的]]></title>
    <url>%2F2019%2F08%2F19%2F%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0Spring-IOC%E7%9A%84%2F</url>
    <content type="text"><![CDATA[前言 众所周知，Spring不仅只是一个框架，Spring已然成为一种生态。它的出现大大简化了企业级应用程序开发，与我们的工作紧密相关，居然它这么重要，我们更应该去深入源码级的学习它，深入了解Spring不仅可以快速帮助我们排查问题，还会在学习的过程中学到许多设计思想，对我们日常开发也会有很大的帮助。 一、IOC和DI我相信你已经在许许多多的地方都看到过关于 IOC 和 DI 的解释了，但这里我还是不得不提一下它们的概念。 IOC(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。 DI(Dependency Injection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。 可以这么说，DI是依赖于IOC的，其实不仅是DI，AOP也是依赖于IOC的。 二、几个问题① 我们通常如何表示对象和对象的关系？② 那么描述对象关系的文件又存放在哪里？③ 如何统一配置文件的一个标准？④ 如何对不同的配置文件进行解析？ 三、IOC容器是如何干活的IOC 容器的初始化流程是怎么样的呢？ 简单的来说，分为三步，如下图 而这三步又可进行细分，便于我们去阅读源码，如下图 四、Spring核心容器类在源码中，Spring 核心容器类无非以下几个： 1、BeanFactoryBeanFactory 作为最顶层的一个接口类，它定义了IOC 容器的基本功能规范。它根本不关心你的Bean是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。 BeanFactory继承体系图如下： BeanFactory 三个重要子类 ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory。ListableBeanFactory接口表示这些Bean是可列表化的，HierarchicalBeanFactory接口表示的是这些Bean是有继承关系的，即每个Bean有可能有父Bean，而AutowireCapableBeanFactory接口定义了Bean的自动装配规则。 BeanFactory的默认实现类是 DefaultListableBeanFactory 当然，Spring 中的一些 常用的IOC容器实现有ClassPathXmlApplicationContext、WebApplicationContext、GenericApplicationContext 以及ApplicationContext。其中，ClassPathXmlApplicationContext用来处理 xml 文件，WebApplicationContext用来处理Servlet层面的Session、Request、Listener、Filter等等。而ApplicationContext是Spring提供的一个高级的IOC容器，它除了能够提供IOC容器的基本功能外，还为用户提供了附加服务，例如支持信息源，可以实现国际化（实现MessageSource接口）、访问资源（实现 ResourcePatternResolver接口）、支持应用事件（实现ApplicationEventPublisher接口）等。 2、BeanDefinitionSpring IOC 容器管理了我们定义的各种 Bean对象及其相互的关系，Bean对象在Spring 实现中是以 BeanDefinition 来描述的，其继承体系如下： 其中最常用的类是 AbstractBeanDefinition 3、BeanDefinitionReaderBean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对Spring 配置文件的解析。这个解析过程主要通过BeanDefintionReader 来完成。 其继承体系如下： XmlBeanDefinitionReader 用于解析 xml 文件，对于注解方式，不需要专门的类进行解析，而是通过 ClassLoader 可以获得注解的信息，然后直接将其转换成 BeanDefinition。 五、源码解析关于IOC容器的主流程如下： 1、寻找IOC容器初始化入口 2、定位配置文件的 setConfigLocations() 方法 3、AbstractApplicationContext 的 refresh() 方法 4、AbstractApplicationContext 的 obtainFreshBeanFactory() 方法 5、AbstractRefreshableApplicationContext子类的loadBeanDefinitions方法 6、AbstractBeanDefinitionReader 读取Bean 配置资源 7、资源加载器获取要读入的资源 8、XmlBeanDefinitionReader 加载Bean配置资源 9、DocumentLoader 将 Bean配置资源转换为 Document 对象 10、XmlBeanDefinitionReader 解析载入的 Bean 配置资源文件 11、DefaultBeanDefinitionDocumentReader 对Bean定义的 Document对象解析 12、BeanDefinitionParserDelegate 解析Bean配置资源文件中的 bean 元素 13、BeanDefinitionParserDelegate 解析 property 元素 14、解析 property 元素的子元素 15、解析 list 元素 16、解析过后的 BeanDefinition 在IOC容器中注册 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Guava 究竟哪里好？ ———— 使用和避免null]]></title>
    <url>%2F2019%2F08%2F03%2FGoogle-Guava-%E7%A9%B6%E7%AB%9F%E5%93%AA%E9%87%8C%E5%A5%BD%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言我们都知道Goole 是一家以技术型主导的公司，Guava 工程则包含了若干被Google Java 项目广泛依赖的核心库。今天一起来学习一下 基本工具[Basic utilities]。 一、使用和避免null “Null sucks.” -Doug Lea “I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference 我们在开发过程中和null打的交道不算少了，它是模棱两可的，总是引起一些令人困惑的错误，让人很难受。所以，Guava 工具类用快速失败拒绝null值，而不是盲目的接受。 如果有了解过 Goole底层代码库，会知道几乎所有的集合类不接受 Null 值作为元素。因为，相比默默接受null，使用快速失败操作拒绝null值对开发者更有帮助。 Null很少可以明确的表示某种语义，例如，在 map 的get操作返回Null时，可能表示 map 中的值是null，可能是 map中没有key对应的值。Null可以表示失败、成功或几乎任何情况。 但是Null也有合适的使用场景，例如在性能和速度方面Null是廉价的。但在应用级别的代码中，Null往往是导致混乱、疑难问题的元凶。鉴于这些原因，很多Guava工具类对Null值都采用快速失败操作，除非工具类本身提供了针对Null值的因变措施。此外，Guava还提供了很多工具类，让你更方便地用特定值替换Null值。 如果真的需要Null值，但是Null值不能和Guava中的集合实现一起工作，你只能选择其他实现。比如用JDK中的Collections.unmodifiableList替代Guava的ImmutableList。 OptionalGuava用Optional表示可能为null的T类型引用。一个Optional实例可能包含非null的引用（我们称之为引用存在），也可能什么也不包括（称之为引用缺失）。它从不说包含的是null值，而是用存在或缺失来表示。但Optional从不会包含null值引用。 创建Optional实例（以下都是静态方法）： Optional.of(T) 创建指定引用的Optional实例，若引用为null则快速失败 Optional.absent() 创建引用缺失的Optional实例 Optional.fromNullable(T) 创建指定引用的Optional实例，若引用为null则表示缺失 用Optional实例查询引用（以下都是非静态方法）： boolean isPresent() 如果Optional包含非null的引用（引用存在），返回true T get() 返回Optional所包含的引用，若引用缺失，则抛出java.lang.IllegalStateException T or(T) 返回锁包含的引用，若引用缺失，返回指定的值 T orNull() 返回锁包含的引用，若引用缺失，返回null Set asSet() 返回Optional所包含引用的单例不可变集，如果引用存在，返回一个只有单一元素的集合，如果引用缺失，返回一个空集合。 使用Optional的意义在哪儿？不仅增强了代码可读性，其最大优点是它是一种傻瓜式的防护。Optional迫使你积极思考引用缺失的情况，因为你必须显示地从 Optional获取引用，直接使用null很容易让人忘掉某些情形。 其他处理null的便利方法当你需要用一个默认值来替换可能的null，请使用Objects.firstNonNull(T, T) 方法。如果两个值都是null，该方法会抛出NullPointerException。Optional也是一个比较好的替代方案，例如：Optional.of(first).or(second). 还有其它一些方法专门处理null或空字符串：emptyToNull(String)，nullToEmpty(String)，isNullOrEmpty(String)。我们想要强调的是，这些方法主要用来与混淆null/空的API进行交互。当每次你写下混淆null/空的代码时，Guava团队都泪流满面。（好的做法是积极地把null和空区分开，以表示不同的含义，在代码中把null和空同等对待是一种令人不安的坏味道。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天来聊聊Java中的语法糖]]></title>
    <url>%2F2019%2F07%2F24%2F%E4%BB%8A%E5%A4%A9%E6%9D%A5%E8%81%8A%E8%81%8AJava%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
    <content type="text"><![CDATA[前言 语法糖是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。Java目前是一个“低糖语言”，未来还会持续向着“高糖”的方向发展。 1.自动拆装箱2.泛型与类型擦除3.枚举类4.内部类5.断言6.变长参数7.增强for循环8.switch支持String与枚举9.try-with-resource10.Lambda表达式 一、自动拆装箱自动装箱：Java虚拟机会自动调用Integer的valueOf方法自动拆箱：Java虚拟机会自动调用Integer的intValue方法 二、泛型与类型擦除泛型编译出来的代码是会把类型擦除的，如果擦除动作导致两个方法的特征签名变得一模一样，那么是不能成功编译的。 三、枚举类Java枚举编译后实际上是生成了一个类，该类继承java.lang.Enum，并添加了一个返回枚举数组的values()方法和valueOf()方法。 四、内部类Java内部类仅仅是一个编译时的概念，outer.java里面定义了一个内部类inner，一旦编译成功，就会生成两个不同的.class文件，分别是outer.class 和 outer$inner.class。所以内部类的名字完全可以和它的外部类名字相同。 五、断言Assert.notNull(stringList， “null array”); 六、变长参数JDK1.5中引入，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数是Java中的语法糖，其内部实现是Java数组。 七、增强for循环增强for循环与普通for循环相比，功能更强并且代码更简洁。增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。 八、switch支持String与枚举从Java7开始，switch 中支持 String 与枚举。对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如byte、short、char、int。反编译后发现，对String的支持是通过equals() 和 hashCode() 方法来实现的。 九、try-with-resourceJava里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄漏等问题。 关闭资源常用的方式是在final块里释放，即调用close方法。从Java7开始，jdk提供了一种更好的方式关闭资源，使用try-with-resources语句。 其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。 十、Lambda表达式Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。 例如： 1234public static void main(String... args) { List strList = ImmutableList.of("a", "b", "c"); strList.forEach( s -> { System.out.println(s); } ); } 实际实现：其实是调用了java.lang.invoke.LambdaMetafactory#metafactory方法，该方法的第四个参数implMethod指定了方法实现。可以看到这里其实是调用了一个lambda$main$0方法进行了输出。 1strList.forEach((Consumer)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)()); lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法糖</tag>
      </tags>
  </entry>
</search>
