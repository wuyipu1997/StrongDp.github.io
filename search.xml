<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Google Guava 究竟哪里好？ ———— 使用和避免null]]></title>
    <url>%2F2019%2F08%2F03%2FGoogle-Guava-%E7%A9%B6%E7%AB%9F%E5%93%AA%E9%87%8C%E5%A5%BD%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言我们都知道Goole 是一家以技术型主导的公司，Guava 工程则包含了若干被Google Java 项目广泛依赖的核心库。今天一起来学习一下 基本工具[Basic utilities]。 一、使用和避免null “Null sucks.” -Doug Lea “I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference 我们在开发过程中和null打的交道不算少了，它是模棱两可的，总是引起一些令人困惑的错误，让人很难受。所以，Guava 工具类用快速失败拒绝null值，而不是盲目的接受。 如果有了解过 Goole底层代码库，会知道几乎所有的集合类不接受 Null 值作为元素。因为，相比默默接受null，使用快速失败操作拒绝null值对开发者更有帮助。 Null很少可以明确的表示某种语义，例如，在 map 的get操作返回Null时，可能表示 map 中的值是null，可能是 map中没有key对应的值。Null可以表示失败、成功或几乎任何情况。 但是Null也有合适的使用场景，例如在性能和速度方面Null是廉价的。但在应用级别的代码中，Null往往是导致混乱、疑难问题的元凶。鉴于这些原因，很多Guava工具类对Null值都采用快速失败操作，除非工具类本身提供了针对Null值的因变措施。此外，Guava还提供了很多工具类，让你更方便地用特定值替换Null值。 如果真的需要Null值，但是Null值不能和Guava中的集合实现一起工作，你只能选择其他实现。比如用JDK中的Collections.unmodifiableList替代Guava的ImmutableList。 OptionalGuava用Optional表示可能为null的T类型引用。一个Optional实例可能包含非null的引用（我们称之为引用存在），也可能什么也不包括（称之为引用缺失）。它从不说包含的是null值，而是用存在或缺失来表示。但Optional从不会包含null值引用。 创建Optional实例（以下都是静态方法）： Optional.of(T) 创建指定引用的Optional实例，若引用为null则快速失败 Optional.absent() 创建引用缺失的Optional实例 Optional.fromNullable(T) 创建指定引用的Optional实例，若引用为null则表示缺失 用Optional实例查询引用（以下都是非静态方法）： boolean isPresent() 如果Optional包含非null的引用（引用存在），返回true T get() 返回Optional所包含的引用，若引用缺失，则抛出java.lang.IllegalStateException T or(T) 返回锁包含的引用，若引用缺失，返回指定的值 T orNull() 返回锁包含的引用，若引用缺失，返回null Set asSet() 返回Optional所包含引用的单例不可变集，如果引用存在，返回一个只有单一元素的集合，如果引用缺失，返回一个空集合。 使用Optional的意义在哪儿？不仅增强了代码可读性，其最大优点是它是一种傻瓜式的防护。Optional迫使你积极思考引用缺失的情况，因为你必须显示地从 Optional获取引用，直接使用null很容易让人忘掉某些情形。 其他处理null的便利方法当你需要用一个默认值来替换可能的null，请使用Objects.firstNonNull(T, T) 方法。如果两个值都是null，该方法会抛出NullPointerException。Optional也是一个比较好的替代方案，例如：Optional.of(first).or(second). 还有其它一些方法专门处理null或空字符串：emptyToNull(String)，nullToEmpty(String)，isNullOrEmpty(String)。我们想要强调的是，这些方法主要用来与混淆null/空的API进行交互。当每次你写下混淆null/空的代码时，Guava团队都泪流满面。（好的做法是积极地把null和空区分开，以表示不同的含义，在代码中把null和空同等对待是一种令人不安的坏味道。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天来聊聊Java中的语法糖]]></title>
    <url>%2F2019%2F07%2F24%2F%E4%BB%8A%E5%A4%A9%E6%9D%A5%E8%81%8A%E8%81%8AJava%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
    <content type="text"><![CDATA[前言 语法糖是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。Java目前是一个“低糖语言”，未来还会持续向着“高糖”的方向发展。 1.自动拆装箱2.泛型与类型擦除3.枚举类4.内部类5.断言6.变长参数7.增强for循环8.switch支持String与枚举9.try-with-resource10.Lambda表达式 一、自动拆装箱自动装箱：Java虚拟机会自动调用Integer的valueOf方法自动拆箱：Java虚拟机会自动调用Integer的intValue方法 二、泛型与类型擦除泛型编译出来的代码是会把类型擦除的，如果擦除动作导致两个方法的特征签名变得一模一样，那么是不能成功编译的。 三、枚举类Java枚举编译后实际上是生成了一个类，该类继承java.lang.Enum，并添加了一个返回枚举数组的values()方法和valueOf()方法。 四、内部类Java内部类仅仅是一个编译时的概念，outer.java里面定义了一个内部类inner，一旦编译成功，就会生成两个不同的.class文件，分别是outer.class 和 outer$inner.class。所以内部类的名字完全可以和它的外部类名字相同。 五、断言Assert.notNull(stringList， “null array”); 六、变长参数JDK1.5中引入，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数是Java中的语法糖，其内部实现是Java数组。 七、增强for循环增强for循环与普通for循环相比，功能更强并且代码更简洁。增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。 八、switch支持String与枚举从Java7开始，switch 中支持 String 与枚举。对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如byte、short、char、int。反编译后发现，对String的支持是通过equals() 和 hashCode() 方法来实现的。 九、try-with-resourceJava里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄漏等问题。 关闭资源常用的方式是在final块里释放，即调用close方法。从Java7开始，jdk提供了一种更好的方式关闭资源，使用try-with-resources语句。 其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。 十、Lambda表达式Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。 例如： 1234public static void main(String... args) { List strList = ImmutableList.of("a", "b", "c"); strList.forEach( s -> { System.out.println(s); } ); } 实际实现：其实是调用了java.lang.invoke.LambdaMetafactory#metafactory方法，该方法的第四个参数implMethod指定了方法实现。可以看到这里其实是调用了一个lambda$main$0方法进行了输出。 1strList.forEach((Consumer)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)()); lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法糖</tag>
      </tags>
  </entry>
</search>
